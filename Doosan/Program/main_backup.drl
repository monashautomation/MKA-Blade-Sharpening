#import struct
#movej(ikin(System_blades_top,2),10,20)
#movej(ikin(System_init,2),10,20)
#movej(System_init_j,100,20)
#hello = get_tool_force(DR_WORLD)
#tp_log("Current Force: " + str(hello))
#hello2 = check_force_condition(DR_AXIS_Z, min=0, max=50, ref=DR_WORLD)
#hello3 = check_force_condition(DR_AXIS_X, min=0, max=50, ref=DR_WORLD)
#hello4 = check_force_condition(DR_AXIS_Y, min=0, max=50, ref=DR_WORLD)
#force_ext = get_tool_force(DR_WORLD)[2]
#tp_log("Current Force Z: " + str(hello2))
#tp_log("Current Force X: " + str(hello3))
#tp_log("Current Force Y: " + str(hello4))
#tp_log("Tool force: " +str(force_ext))
## 5 ≤f_z≤10
 #
#while (get_tool_force(DR_WORLD)[2] > -100):
  #fcon2 = check_force_condition(DR_AXIS_C, min=30)              # 30≤m_z
  ##pcon1 = check_position_condition(DR_AXIS_X, min=0, max=0.1)    # 0≤x≤0.1
 #
  #if (fcon2 and pcon1):
    #break
    #
  #wait(1)
#
#tp_log("Moving arm in 5")
#wait(5)
#
#movej(System_init_j,100,20)
#
#g_sock = server_socket_open(20002)
#while 1:
    #server_socket_write(g_sock, b"abcd")
          ## The string “abcd” is sent in a byte type.
    #wait(0.1)
    #res, rx_data = server_socket_read(g_sock)
          ## Waits for the data from the server.
    ##tp_popup("res={0}, rx_data ={1}".format(res, rx_data), DR_PM_MESSAGE)
    #wait(0.1)
    #if res>0:
        #rx_msg = rx_data.decode()
        #if rx_msg == "1234":
            #break
#
#movel(System_blades_top,100,20)
#
#server_socket_close(g_sock)

s_sock = client_socket_open("172.24.70.40",20002)
#s_sock = client_socket_open("172.24.9.15",5000)
# while 1:
#     res, rx_data = client_socket_read(s_sock, length=1000)
#     tp_log(str(res))
#     if res>0:
#         rx_msg = rx_data.decode()
#         if rx_msg == "init":
#             movej(System_init_j,100,20)
#             client_socket_write(s_sock, b"Done")
#             continue
#         elif rx_msg == "btop":
#             movel(System_blades_top_new,100,20)
#             client_socket_write(s_sock, b"Done")
#             continue
#         elif rx_msg == "pos1":
#             movel(System_blade1_new,100,20)
#             client_socket_write(s_sock, b"Done")
#             continue
#         elif rx_msg == "gtop":
#             movel(System_grinder_top,100,20)
#             client_socket_write(s_sock, b"Done")
#             continue
#         elif rx_msg == "grind":
#             movel(System_grinder,100,20)
#             client_socket_write(s_sock, b"Done")
#             continue
#         elif rx_msg == "gapp":
#             movel(System_grinder_app,100,20)
#             client_socket_write(s_sock, b"Done")
#             continue
#         elif rx_msg[0] == "i":
#             tp_log("Received something")
#             continue
#         elif rx_msg == "bye":
#             break
#         else:
#             tp_log(rx_msg)
#         wait(5)
            
# client_socket_close(s_sock)
#
#while True:
    ## Read data (default buffer is fine)
    #res, rx_data = client_socket_read(s_sock)
    #
    #if res > 0:
        ## --- PATH A: BINARY PACKET HANDLING (9 Bytes) ---
        ## We check if length is 9 AND the first byte is 1 (our Move Command ID)
        #if res == 9 and rx_data[0] == 1:
            #
            ## Unpack: >Bff (Byte, Float, Float)
            #unpacked = struct.unpack('>Bff', rx_data)
            #val_x = unpacked[1]
            #val_y = unpacked[2]
            #
            #tp_log("Binary Move Received: X={0}, Y={1}".format(val_x, val_y))
            #
            ## Execute Relative Move (based on X/Y inputs)
            ## We assume these are offsets in mm
            #delta = [val_x, val_y, 0, 0, 0, 0]
            #movel(pos(delta), mod=DR_MV_MOD_REL)
            #
            #client_socket_write(s_sock, b"Done")
            #continue # Skip the rest of the loop
#
        ## --- PATH B: TEXT COMMAND HANDLING ---
        ## If it wasn't a binary packet, try to read it as text
        #try:
            #rx_msg = rx_data.decode().strip() # .strip() cleans up spaces/newlines
        #except:
            #tp_log("Error: Received data that is not text or valid binary.")
            #continue
#
        ## Existing Logic
        #if rx_msg == "init":
            #movej(System_init_j, 100, 20)
            #client_socket_write(s_sock, b"Done")
            #
        #elif rx_msg == "btop":
            #movel(System_blades_top_new, 100, 20)
            #client_socket_write(s_sock, b"Done")
            #
        #elif rx_msg == "pos1":
            #movel(System_blade1_new, 100, 20)
            #client_socket_write(s_sock, b"Done")
            #
        #elif rx_msg == "gtop":
            #movel(System_grinder_top, 100, 20)
            #client_socket_write(s_sock, b"Done")
            #
        #elif rx_msg == "grind":
            #movel(System_grinder, 100, 20)
            #client_socket_write(s_sock, b"Done")
            #
        #elif rx_msg == "gapp":
            #movel(System_grinder_app, 100, 20)
            #client_socket_write(s_sock, b"Done")
            #
        #elif rx_msg == "bye":
            #tp_log("Closing connection.")
            #break
            #
        #else:
            #tp_log("Unknown Command: " + rx_msg)
            #
    ## CRITICAL: Reduced wait time so robot responds quickly
    #wait(0.1) 
#
#client_socket_close(s_sock)

while 1:
    # Read data (default buffer is fine)
    res, rx_data = client_socket_read(s_sock)
    
    if res > 0:
        if res == 9 and rx_data[0] == 1:
            
            # Unpack: >Bff (Byte, Float, Float)
            val_x = int.from_bytes(rx_data[1:5], byteorder='big', signed=True)
            val_y = int.from_bytes(rx_data[5:9], byteorder='big', signed=True)
            
            tp_log("Binary Move Received: X={0}, Y={1}".format(val_x, val_y))
            
            # Execute Relative Move (based on X/Y inputs)
            # We assume these are offsets in mm
            delta_x = [val_x/100, 0, 0, 0, 0, 0]
            delta_y = [0, val_y/100, 0, 0, 0, 0]
            movel(posx(delta_x), vel=10, acc=10,mod=DR_MV_MOD_REL)
            wait(0.5)
            movel(posx(delta_y), vel=10, acc=10,mod=DR_MV_MOD_REL)
            wait(0.5)
            movel(posx(-delta_y), vel=10, acc=10,mod=DR_MV_MOD_REL)
            
            client_socket_write(s_sock, b"Done")
            continue # Skip the rest of the loop

        # --- PATH B: TEXT COMMAND HANDLING ---
        # If it wasn't a binary packet, try to read it as text
        try:
            rx_msg = rx_data.decode() # .strip() cleans up spaces/newlines
        except:
            tp_log("Error: Received data that is not text or valid binary.")
            continue

        # Existing Logic
        if rx_msg == "init":
            movej(System_init_j, 100, 20)
            client_socket_write(s_sock, b"Done")
            
        elif rx_msg == "btop":
            movel(System_blades_top_new, 100, 20)
            client_socket_write(s_sock, b"Done")
            
        elif rx_msg == "pos1":
            movel(System_blade1_new, 100, 20)
            client_socket_write(s_sock, b"Done")
            
        elif rx_msg == "gtop":
            movel(System_grinder_top, 100, 20)
            client_socket_write(s_sock, b"Done")
            
        elif rx_msg == "grind":
            movel(System_grinder, 100, 20)
            client_socket_write(s_sock, b"Done")
            
        elif rx_msg == "gapp":
            movel(System_grinder_app, 100, 20)
            client_socket_write(s_sock, b"Done")
            
        elif rx_msg == "bye":
            tp_log("Closing connection.")
            break
            
        else:
            tp_log("Unknown Command: " + rx_msg)
            
    # CRITICAL: Reduced wait time so robot responds quickly
    wait(5) 

client_socket_close(s_sock)